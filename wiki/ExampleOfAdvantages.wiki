#summary Show advantages of using this tool.

= Function =

Let's look at some function. This is example and it's a part of the action code.

Function parses information of special data-file, checks it and converts into internal representation.

Only notice, that function has several sub-functions: get_utfmarker_line(), check_elements(), getline(), check_and_union_ranges().

It's just example and function logic doesn't matter.

{{{
void
parse_file( const std::string & filename ) 
{
	std::ifstream file( filename.c_str() );
 
	if ( !file.good() )
	{
		throw phone_ranges_error_t( 
			"Can't open file '" + filename + "' to parse." );
	}
 
	// Receive first line and cut marker (if it present).
	elements_t elements = get_utfmarker_line( file );
 
	// Parse all file and collect map.
	ranges_t ranges;
	while( true )
	{
		check_elements( elements, ranges );
 
		ranges_t::const_iterator it = 
			ranges.find( range_t( elements[0], elements[1] ) );
 
		if ( it == ranges.end() )
			ranges[ range_t( elements[0], elements[1] ) ] = elements[2];
 
		if ( file.eof() )
			break;
 
		elements = getline( file );
	}
 
	check_and_union_ranges( ranges );
 
	m_ranges = ranges;
}
}}}

= Problem =

Let's imagine, that we need to describe context 'filename' if something wrong happened at this function. In other words, if exception occurs, we would like to diagnose (log/send/show/..) filename.

How we can do it?

There are two examples of conventional solution below.

== First: add info to flying exceptions ==

{{{
void
parse_file( const std::string & filename ) 
{
	std::ifstream file( filename.c_str() );

	try
	{
		...
	}
	catch( const std::runtime_error & ex )
	{
		throw std::runtime_error( 
			ex.what() + " parse_file filename:" + filename + ";" );
	}
 
}
}}}

This way has several drawbacks:
 * We need to capture all types of exceptions. As a result:
   * A lot of catches (it leads to the huge code).
   * We can easy forget some type of exception at catch.
   * We can't catch unknown types of exceptions.
 * We need to write try (1) and catch (2) - it's two places of the control. And we have to add one extra tab to all lines of the function. All of this increases complexity of code perception.
 * Catch initiates c'tor of exception instance (ex).

== Second: pass info to sub-functions ==

One of the ways:

{{{
void
parse_file( const std::string & filename ) 
{
	std::ifstream file( filename.c_str() );
 
...
 
	elements_t elements = get_utfmarker_line( file, filename );

...
 
		check_elements( elements, ranges, filename );
 
...

		elements = getline( file, filename );

...
 
	check_and_union_ranges( ranges, filename );

...
}
}}}

There are several disadvantages:
 * One extra parameter to every function:
   * Code will be more complex and support will be painful.
   * We must control every function. And most likely, we'll forget some of this functions.
   * Besides of passing parameter to the function, we need to add information about filename to every throw place.
 * We can't control foreign exceptions.

= Library solution = 

Library provide a wrapper, which automatically collects information if exception occurs.

To do it, we need to add just one line:

{{{
void
parse_file( const std::string & filename ) 
{
	ex_diag::reg<std::string> reg_file ( filename, "parse filename" );
...

}}}

At end-points, where we capture exceptions, we can use all diagnostic information or it will be dumped automatically.

Dump by hand:

{{{
	catch ( ... )
	{
		std::cout << 
			ex_diag::get_collector_instance().info() << std::endl;
	}
}}}

Or do nothing if we have ex-inheritor instance:

{{{
	catch ( const ex_diag::ex_t & ex )
	{
		// Dump will be at ex_diag::ex_t d'tor.
	}
}}}

After a while of wide using, this library allows quickly understand stack traces of failures and makes development easier during all stages.
